<!DOCTYPE HTML>
<!--
    Strongly Typed 1.0 by HTML5 UP
    html5up.net | @n33co
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
    <head>
  <meta charset="utf-8">
  <title>OWIN routing - LINQ to Fail</title>
  <meta name="author" content="Aaron Powell">
  <meta name="viewport" content="width=1040" />
  <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Arvo:700" rel="stylesheet" type="text/css" />
  <link href="/css/highlightjs/solarized_light.css" rel="stylesheet" type="text/css" />
  <script src="/js/jquery-1.9.1.min.js"></script>
  <script src="/js/jquery.dropotron-1.3.js"></script>
  <script src="/js/config.js"></script>
  <script src="/js/skel.min.js"></script>
  <script src="/js/skel-ui.min.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/skel-noscript.css" />
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/style-desktop.css" />
  </noscript>
  <!--[if lte IE 8]><script src="/js/html5shiv.js"></script><![endif]-->

</head>

    <body class="left-sidebar">

        <div id="header-wrapper">
            <div id="header" class="container">
                <h1 id="logo">OWIN routing</h1>
                <h2>16th March 2012</h2>
                <ul class="tags">
    
        <li><a class="icon icon-tag" href="/tagged/owin.html"><span>owin</span></a></li>
    
        <li><a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a></li>
    
</ul>
                <!-- Nav -->
<nav id="nav">
    <ul>
        <li><a class="icon icon-home" href="/"><span>Home</span></a></li>
        <li><a class="icon icon-github" href="https://github.com/aaronpowell"><span>aaronpowell</span></a></li>
        <li><a class="icon icon-twitter" href="http://twitter.com/slace"><span>@slace</span></a></li>
        <li><a class="icon icon-book" href="/about"><span>About Me</span></a></li>
        <li><a class="icon icon-rss" href="/feed"><span>Feed</span></a></li>
    </ul>
</nav>

            </div>
        </div>

        <div id="main-wrapper">
            <div id="main" class="container">
                <div class="row">
                    <div id="sidebar" class="4u">
    <section>
        <ul class="divided">
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">19th April 2013</span>
                            <h3><a href="/posts/2013-04-19-ie-useragents.html">Internet Explorer userAgents</a></h3>
                        </header>
                        <p>A new program from the IE team</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/internet-explorer.html"><span>internet-explorer</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">22nd January 2013</span>
                            <h3><a href="/posts/2013-01-22-hello-mathy.html">Hello mathy</a></h3>
                        </header>
                        <p>An introduction to another new library from me, this time it&#39;s mathy, a simple formula parser</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/typescript.html"><span>typescript</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/javascript.html"><span>javascript</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">14th January 2013</span>
                            <h3><a href="/posts/2013-01-14-ie10-console-thoughts.html">Making the Internet Explorer JavaScript tools better, again</a></h3>
                        </header>
                        <p>A look at what&#39;s changed since I last pointed out the failings of the IE dev tools</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/javascript.html"><span>javascript</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/internet-explorer.html"><span>internet-explorer</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web-dev.html"><span>web-dev</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">18th October 2012</span>
                            <h3><a href="/posts/2012-10-18-dbjs-chrome.html">Chrome support for db.js</a></h3>
                        </header>
                        <p>A little word on the db.js support for Chrome</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/indexeddb.html"><span>indexeddb</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/chrome.html"><span>chrome</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">8th October 2012</span>
                            <h3><a href="/posts/2012-10-08-reverse-order-unique-indexes.html">Reverse order unique queries in IndexedDB</a></h3>
                        </header>
                        <p>The quirk of reverse index querying in IndexedDB and in turn db.js</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/indexeddb.html"><span>indexeddb</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
        </ul>
    </section>
</div>

                    <div id="content" class="8u skel-cell-mainContent">
                        <article class="is-post">
                            <p><a href="http://www.aaron-powell.com/web/owin-and-middleware">Last time around</a> we started looking at middleware in OWIN and how to handle different request types. So now comes the next logical step, how do we handle different URLs? Currently we don&#39;t have the facilities to handle different URLs, aka routing, so let&#39;s work on that.</p>
<h2>Understanding routing</h2>
<p>Before we dive into coding our solution it&#39;s a good idea to think about what routing really is. You&#39;re probably familiar with this from ASP.Net MVC with code such as:</p>
<pre class="highlighted"><code class="objectivec">    routes<span class="variable">.MapRoute</span>(
        <span class="string">"Default"</span>,                                              <span class="comment">// Route name</span>
        <span class="string">"{controller}/{action}/{id}"</span>,                           <span class="comment">// URL with parameters</span>
        new { controller = <span class="string">"Home"</span>, action = <span class="string">"Index"</span>, <span class="keyword">id</span> = <span class="string">""</span> }  <span class="comment">// Parameter defaults</span>
    );</code></pre>
<p>What&#39;s really important is line three, where we are defining what the URL we are going to be targeting looks like. With MVC routing we do a few other things such naming the route and providing default values for the segments of the URL that we&#39;re trying to match but that&#39;s not really of interest to us. If we think about the kinds of URLs we&#39;re going to constructing we can break it down as:</p>
<ul>
<li>There&#39;ll probably something static in the URL</li>
<li>Retrieve records we&#39;ll probably have some kind of pattern to match</li>
<li>Some URL segments may be useful in the handler</li>
</ul>
<p>Ok we understand a bit of <em>how</em> we want to construct our route matching let&#39;s set about implementing it. To do this we&#39;re going to build on top of the extension methods we built last time, but for this we&#39;re going to need to be passing in a URL, well a pattern to match the URLs.</p>
<h1>Defining our route matching</h1>
<p>The first thing we&#39;ll do is look at the routes systems in other middleware projects like <a href="https://github.com/NancyFx/Nancy/wiki/Defining-routes">Nancy</a>, <a href="http://expressjs.com/guide.html#routing">Express.js</a> on Node and <a href="http://www.sinatrarb.com/intro.html#Routes">Sinatra</a> on Ruby. Something that we can see from these three projects (and other middleware projects out there) is that they support the URL matching scenarios I described above (coincidence?) and they do it is similar ways. All allow you to do:</p>
<ul>
<li>A static value</li>
<li>A named value<ul>
<li>This is slightly different in Nancy to the other two, Nancy uses <code>{name}</code> to define a named value where as the others use <code>:name</code></li>
</ul>
</li>
<li>A pattern-matched value</li>
</ul>
<p>For this example I&#39;m going to use the Sinatra/ Express.js routing style (<code>:name</code> not <code>{name}</code>).</p>
<h2>Breaking down our route matching</h2>
<p>So now that we know what we want to be able <em>do</em> in our URLs let&#39;s think about <em>how</em> we&#39;d do it.</p>
<p>Static values should be pretty easy, it&#39;s just a string that we want to match against and equality statements should be right to take care of that, let&#39;s move on.</p>
<p>Named values is next on the list, what we want to do here is take this particular URL segment and then grab the value to provide into our handler, maybe we can get away with just sub-stringing here?</p>
<p>Pattern matching... hmm that&#39;s an interesting one, but you know what it&#39;s not really that hard, there&#39;s a very simple way to do pattern matching... Regex!</p>
<h2>Regex ALL the things!</h2>
<p>Let&#39;s say we want this URL to match:</p>
<pre class="highlighted"><code class="coffeescript"><span class="regexp">/users/1234/unsubscribe/</span>email<span class="property">@mail</span>.com</code></pre>
<p>The URL has two static sections to it, <code>/users/</code> and <code>/unsubscribe/</code>, it also has two dynamic sections, something that we can assume is an id and an email address. Both of these segments likely to be useful within our handler so we&#39;d want to be able to capture them. And if we think about the id segment it&#39;s likely we have some kind of a pattern that could represent it and for the email we just want to capture it (althought it&#39;s true we could also put a pattern in place to match the email <a href="http://haacked.com/archive/2007/08/21/i-knew-how-to-validate-an-email-address-until-i.aspx">but email matching is complex</a> so I don&#39;t want to match it in our URL, that&#39;s for the business logic to validate).</p>
<p>Now let&#39;s look at a pattern for the URL to meet our requirements:</p>
<pre class="highlighted"><code class="javascript">/users/(?<span class="xml"><span class="tag">&lt;<span class="title">id</span>&gt;</span>\d{1,5})/unsubscribe/:email</span></code></pre>
<p>Alright that&#39;s looking good, we&#39;ve got a regex to restrict our id to be what we have known in our system and we&#39;ve said we want to capture the email, but how would we <em>actually</em> match that URL? The answer... regex the whole URL (regardless of whether I now have <a href="http://regex.info/blog/2006-09-15/247">two problems</a>)! The reason I want to regex the URL is otherwise we have to do a bunch of string splitting, manipulation and guff code just to match all the segments, which is really what we are doing in a Regex itself.</p>
<p>So I&#39;m going to start with a new extension methods class called <code>Routing</code> and we&#39;ll focus on processing GET requests (and can refactor later for the other verbs). Inside this class I&#39;m going to create a private method to break down our URL pattern into something that&#39;ll actually match:</p>
<pre class="highlighted"><code class="cs">    <span class="keyword">private</span> <span class="keyword">static</span> Regex RouteToRegex(<span class="keyword">string</span> route)
    {
       <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();
    }</code></pre>
<p>The first thing I want to do is split out each segment of the URL:</p>
<pre class="highlighted"><code class="cs">    <span class="keyword">private</span> <span class="keyword">static</span> Regex RouteToRegex(<span class="keyword">string</span> route)
    {
        <span class="keyword">var</span> parts = route.Split(<span class="keyword">new</span>[] { <span class="string">"/"</span> }, StringSplitOptions.RemoveEmptyEntries).AsEnumerable();

        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();
    }</code></pre>
<p>This gives us an array like so:</p>
<pre class="highlighted"><code class="ini"><span class="setting">parts[0] =<span class="value">= <span class="string">"users"</span></span></span>
<span class="setting">parts[1] =<span class="value">= <span class="string">"(?&lt;id&gt;\d{1,5})"</span></span></span>
<span class="setting">parts[2] =<span class="value">= <span class="string">"unsubscribe"</span></span></span>
<span class="setting">parts[3] =<span class="value">= <span class="string">":email"</span></span></span></code></pre>
<p>Well then, three out of those four parts <em>look like regexs already</em>, want to match the work <strong>users</strong>, well <strong>users</strong> will do that. Want to capture a number one to five characters in length, well we&#39;ve got a named capture group for that too. The only thing that doesn&#39;t look like a regex is <code>:email</code>, but is something that looks unique and we could match against.</p>
<p>Now we need to go through the array and find any of these <code>:email</code>-esq values and turn them into <strong>named catch-all groups</strong> as that&#39;s what we want to do. Again, regex comes to the rescue, and with this I&#39;m going to some LINQ trickery:</p>
<pre class="highlighted"><code class="objectivec">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Regex paramRegex = new Regex(@<span class="string">":(?&lt;name&gt;[A-Za-z0-9_]*)"</span>, RegexOptions<span class="variable">.Compiled</span>);
    <span class="keyword">private</span> <span class="keyword">static</span> Regex RouteToRegex(string route)
    {
        var parts = route<span class="variable">.Split</span>(new[] { <span class="string">"/"</span> }, StringSplitOptions<span class="variable">.RemoveEmptyEntries</span>)<span class="variable">.AsEnumerable</span>();

        parts = parts<span class="variable">.Select</span>(part =&gt; !paramRegex<span class="variable">.IsMatch</span>(part) ? 
            part :
            string<span class="variable">.Join</span>(<span class="string">""</span>,
                paramRegex<span class="variable">.Matches</span>(part)
                    <span class="variable">.Cast</span>&lt;Match&gt;()
                    <span class="variable">.Where</span>(match =&gt; match<span class="variable">.Success</span>)
                    <span class="variable">.Select</span>(match =&gt; string<span class="variable">.Format</span>(
                        <span class="string">"(?&lt;{0}&gt;.+?)"</span>,
                        match<span class="variable">.Groups</span>[<span class="string">"name"</span>]<span class="variable">.Value</span><span class="variable">.Replace</span>(<span class="string">"."</span>, @<span class="string">"\."</span>)
                        )
                    )
                )
            );

        <span class="keyword">throw</span> new NotImplementedException();
    }</code></pre>
<p>First off I&#39;ve created a regex to <em>match our catch-all</em> which resides in the static field. Next I&#39;m going to go through each of the URL segments and if they aren&#39;t a match to the pattern then they are already regexable and we&#39;ll just return them, otherwise we&#39;ll get all the matches and then them into the named catch-all capture group. Our array will then look like this:</p>
<pre class="highlighted"><code class="ini"><span class="setting">parts[0] =<span class="value">= <span class="string">"users"</span></span></span>
<span class="setting">parts[1] =<span class="value">= <span class="string">"(?&lt;id&gt;\d{1,5})"</span></span></span>
<span class="setting">parts[2] =<span class="value">= <span class="string">"unsubscribe"</span></span></span>
<span class="setting">parts[3] =<span class="value">= <span class="string">"(?&lt;email&gt;.+?)"</span></span></span></code></pre>
<p>Lastly we&#39;ll rejoin all the regex parts with <code>/</code> separators so that it is back to being a URL as well as put start and end terminators (we&#39;ll also make it case-insensitive and compile the regex for speed):</p>
<pre class="highlighted"><code class="objectivec">    <span class="keyword">private</span> <span class="keyword">static</span> Regex RouteToRegex(string route)
    {
        var parts = route<span class="variable">.Split</span>(new[] { <span class="string">"/"</span> }, StringSplitOptions<span class="variable">.RemoveEmptyEntries</span>)<span class="variable">.AsEnumerable</span>();

        parts = parts<span class="variable">.Select</span>(part =&gt; !paramRegex<span class="variable">.IsMatch</span>(part) ? 
            part :
            string<span class="variable">.Join</span>(<span class="string">""</span>,
                paramRegex<span class="variable">.Matches</span>(part)
                    <span class="variable">.Cast</span>&lt;Match&gt;()
                    <span class="variable">.Where</span>(match =&gt; match<span class="variable">.Success</span>)
                    <span class="variable">.Select</span>(match =&gt; string<span class="variable">.Format</span>(
                        <span class="string">"(?&lt;{0}&gt;.+?)"</span>,
                        match<span class="variable">.Groups</span>[<span class="string">"name"</span>]<span class="variable">.Value</span><span class="variable">.Replace</span>(<span class="string">"."</span>, @<span class="string">"\."</span>)
                        )
                    )
                )
            );

        <span class="keyword">return</span> new Regex(<span class="string">"^/"</span> + string<span class="variable">.Join</span>(<span class="string">"/"</span>, parts) + <span class="string">"$"</span>, RegexOptions<span class="variable">.Compiled</span> | RegexOptions<span class="variable">.IgnoreCase</span>);
    }</code></pre>
<p>Ta-Da! We now have a matching algorithm like so:</p>
<pre class="highlighted"><code class="javascript">^<span class="regexp">/users/</span>(?<span class="xml"><span class="tag">&lt;<span class="title">id</span>&gt;</span>\d{1,5})/unsubscribe/(?<span class="tag">&lt;<span class="title">email</span>&gt;</span>.+?)$</span></code></pre>
<p>Paste that into your favourite regex tester and take it for a whirl!</p>
<h1>Matching our route</h1>
<p>Now that we <em>can</em> match our route maybe we should expose that. As I said we&#39;ll create an extension method that allows us to do this:</p>
<pre class="highlighted"><code class="cs"><span class="keyword">public</span> <span class="keyword">static</span> IAppBuilder Get(<span class="keyword">this</span> IAppBuilder builder, <span class="keyword">string</span> route, Action&lt;Request, Response&gt; app)
{
    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();
}</code></pre>
<p>This looks like the one from the last post but we&#39;re taking in a route as the first argument, meaning we can do:</p>
<pre class="highlighted"><code class="avrasm">builder<span class="preprocessor">.Get</span>(@<span class="string">"/users/(?&lt;id&gt;\d{1,5})/unsubscribe/:email"</span>, (req, res) =&gt; {
    res<span class="preprocessor">.ContentType</span> = <span class="string">"text/plain"</span><span class="comment">;</span>
    res<span class="preprocessor">.End</span>(<span class="string">"Unsibscribed\r\b"</span>)<span class="comment">;</span>
})<span class="comment">;</span></code></pre>
<p>The logic of this method isn&#39;t going to be much different to the ones from the last post with the addition of doing a match against our regex:</p>
<pre class="highlighted"><code class="vbscript">    <span class="keyword">public</span> static IAppBuilder <span class="keyword">Get</span>(this IAppBuilder builder, <span class="built_in">string</span> route, Action&lt;<span class="built_in">Request</span>, <span class="built_in">Response</span>&gt; app)
    {
        var regex = RouteToRegex(route);

        return builder.Use&lt;AppDelegate&gt;(<span class="keyword">next</span> =&gt; (env, result, fault) =&gt;
        {
            var path = (<span class="built_in">string</span>)env[<span class="string">"owin.RequestPath"</span>];

            <span class="keyword">if</span> (path.EndsWith(<span class="string">"/"</span>))
            {
                path = path.TrimEnd(<span class="comment">'/');</span>
            }

            <span class="keyword">if</span> ((<span class="built_in">string</span>)env[<span class="string">"owin.RequestMethod"</span>] == <span class="string">"GET"</span> &amp;&amp; regex.IsMatch(path))
            {
                var req = <span class="keyword">new</span> <span class="built_in">Request</span>(env);
                var res = <span class="keyword">new</span> <span class="built_in">Response</span>(result);
                app(req, res);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">next</span>(env, result, fault);
            }
        });
    }</code></pre>
<p>So up front we create our regex and then inside the handler we will match against it as well as checking the Request verb. You&#39;ll see that we&#39;re getting the URL (path) out, again this comes from the OWIN Environment Variables. The only other thing we&#39;re doing is stripping the trailing <code>/</code>. This is more personal preference (and I&#39;m sure some SEO expert can give a good reason for it) but you don&#39;t have to remove it if you don&#39;t want, you&#39;d just have to ensure the regex can handle that scenario.</p>
<p>But now we&#39;re able to filter the requests by URL and it&#39;s all going to track nicely for us!</p>
<h1>Capturing our URL segments</h1>
<p>As I said earlier in the post generally when we have a specific URL segment to match we do that because we care about the value and we&#39;ll be wanting it in our handler. Currently though we&#39;re not passing that in are we? Well we should solve that! At the moment I&#39;m using the Gate <code>Request</code> object for the handler but it wont really do what I want here, at least not in an overly discoverable way (since it inherits from a <code>Dictionary&lt;string, object&gt;</code> it&#39;s not too hard but I want to make it easier). Instead I want to extend it, so I&#39;m going to create a superclass called <code>RoutedRequest</code>.</p>
<p>In the <code>RoutedRequest</code> class I want to surface any of the matched segments and to do this I&#39;m going to use a <a href="http://www.aaron-powell.com/dynamics-library">helper class I wrote a while ago for using Dynamics</a> and pass in a dictionary that represents all matched values. This makes our <code>RoutedRequest</code> class nice and simple:</p>
<pre class="highlighted"><code class="vala"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutedRequest</span> : <span class="title">Request</span>
{</span>
    <span class="keyword">public</span> RoutedRequest(IDictionary&lt;<span class="keyword">string</span>, object&gt; env, Regex regex, <span class="keyword">string</span> path):
        base(env)
    {
        <span class="keyword">var</span> groups = regex.Match(path).Groups;
        <span class="keyword">var</span> dic = regex.GetGroupNames().ToDictionary(name =&gt; name, name =&gt; groups[name].Value);

        UrlSegments = <span class="keyword">new</span> DynamicDictionary&lt;<span class="keyword">string</span>&gt;(dic);
    }

    <span class="keyword">public</span> dynamic UrlSegments { <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; }
}</code></pre>
<p>Now once we update the <code>Get</code> method we can update our handler like this:</p>
<pre class="highlighted"><code class="avrasm">builder
            <span class="preprocessor">.Get</span>(@<span class="string">"/users/(?&lt;id&gt;\d{1,5})/subscribed/:email"</span>, (req, res) =&gt;
            {
                res<span class="preprocessor">.ContentType</span> = <span class="string">"text/plain"</span><span class="comment">;</span>
                res<span class="preprocessor">.End</span>(<span class="string">"Email "</span> + req<span class="preprocessor">.UrlSegments</span><span class="preprocessor">.email</span> + <span class="string">" is subscribed.\r\n"</span>)<span class="comment">;</span>
            })<span class="comment">;</span></code></pre>
<p>You&#39;ll notice that off the <code>req</code> object we can go through the <code>UrlSegments</code> property and use <em>dot-notation</em> to access the email address that was submitted. This is pretty sexy if I do say so myself.</p>
<h1>Conclusion</h1>
<p>I&#39;ll admit that this was quite a long post as the subject of routing <em>is a complex one</em>. Hopefully though you&#39;ve seen that without a lot of code we&#39;ve made a phenomenally powerful little route engine (really, it&#39;s quite a simple bit of code in the end).</p>
<p>While the route that we&#39;ve been looking at is rather complex our little engine is capable of pretty much anything, we don&#39;t <em>need</em> to be putting in regexs, we can get away with routes like <code>/home</code> or <code>/about</code> as well.</p>
<p>Next time we&#39;ll look at how we can make our responses more powerful with simple helper methods.</p>
<p>As always you can check out the full code up on the <a href="https://github.com/aaronpowell/Owin.HelloWorld">GitHub repository</a>.</p>

                        </article>
                    </div>
                    <div class="8u skel-cell-mainContent">
                        <article class="is-post">
                            <div id="disqus_thread"></div>
<script>
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
window.disqus_shortname = 'aaronpowell'; // required: replace example with your forum shortname
window.disqus_identifier = document.title || 'Home';
window.disqus_developer = !! ~document.location.href.indexOf("localhost") ? 1 : 0;
window.disqus_url = document.location.origin + '/web/owin-routing';

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by</a>
<span class="logo-disqus"> Disqus</span>

                        </article>
                    </div>
                </div>
            </div>
        </div>

        <div id="footer-wrapper">

    <!-- Copyright -->
        <div id="copyright" class="container">
            <ul class="links">
                <li>&copy; Aaron Powell. All rights reserved</li>
                <li>Design: <a href="http://html5up.net/">HTML5 UP</a></li>
            </ul>
        </div>

</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-6399564-1']);
  _gaq.push(['_trackPageview']);

  (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
  })();

</script>

    </body>
</html>