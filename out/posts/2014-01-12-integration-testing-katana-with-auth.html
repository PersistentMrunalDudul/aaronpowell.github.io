<!DOCTYPE HTML>
<!--
    Strongly Typed 1.0 by HTML5 UP
    html5up.net | @n33co
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
    <head>
  <meta charset="utf-8">
  <title>Integration testing authenticated Katana applications - LINQ to Fail</title>
  <meta name="author" content="Aaron Powell">
  <meta name="viewport" content="width=1040" />
  <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Arvo:700" rel="stylesheet" type="text/css" />
  <link href="/css/highlightjs/solarized_light.css" rel="stylesheet" type="text/css" />
  <script src="/js/jquery-1.9.1.min.js"></script>
  <script src="/js/jquery.dropotron-1.3.js"></script>
  <script src="/js/config.js"></script>
  <script src="/js/skel.min.js"></script>
  <script src="/js/skel-ui.min.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/skel-noscript.css" />
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/style-desktop.css" />
  </noscript>
  <!--[if lte IE 8]><script src="/js/html5shiv.js"></script><![endif]-->

</head>

    <body class="left-sidebar">

        <div id="header-wrapper">
            <div id="header" class="container">
                <h1 id="logo">Integration testing authenticated Katana applications</h1>
                <h2>12th January 2014</h2>
                <ul class="tags">
    
        
            <li><a class="icon icon-tag" href="/tagged/owin.html"><span>owin</span></a></li>
        
            <li><a class="icon icon-tag" href="/tagged/katana.html"><span>katana</span></a></li>
        
            <li><a class="icon icon-tag" href="/tagged/testing.html"><span>testing</span></a></li>
        
    
</ul>
                <!-- Nav -->
<nav id="nav">
    <ul>
        <li><a class="icon icon-home" href="/"><span>Home</span></a></li>
        <li><a class="icon icon-github" href="https://github.com/aaronpowell"><span>aaronpowell</span></a></li>
        <li><a class="icon icon-twitter" href="http://twitter.com/slace"><span>@slace</span></a></li>
        <li><a class="icon icon-book" href="/about"><span>About Me</span></a></li>
        <li><a class="icon icon-rss" href="/feed"><span>Feed</span></a></li>
    </ul>
</nav>

            </div>
        </div>

        <div id="main-wrapper">
            <div id="main" class="container">
                <div class="row">
                    <div id="sidebar" class="4u">
    <section>
        <ul class="divided">
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">10th April 2012</span>
                            <h3><a href="/posts/2012-04-10-owin-conclusion.html">OWIN series conclusion</a></h3>
                        </header>
                        <p>Wrapping up the OWIN series</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/owin.html"><span>owin</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">2nd April 2012</span>
                            <h3><a href="/posts/2012-04-02-owin-view-engines-part-2.html">OWIN and View Engines, Part 2</a></h3>
                        </header>
                        <p>Taking the View Engine concept one step further</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/owin.html"><span>owin</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">23rd March 2012</span>
                            <h3><a href="/posts/2012-03-23-owin-view-engines.html">OWIN and View Engines</a></h3>
                        </header>
                        <p>A look at how you&#39;d put together a View Engine for OWIN.</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/owin.html"><span>owin</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">19th March 2012</span>
                            <h3><a href="/posts/2012-03-19-owin-responses.html">OWIN Responses</a></h3>
                        </header>
                        <p>A look at how to give power to our responses by making different response types easier to handle</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/owin.html"><span>owin</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
                <li>
                    <article class="is-excerpt">
                        <header>
                            <span class="date">16th March 2012</span>
                            <h3><a href="/posts/2012-03-16-owin-routing.html">OWIN routing</a></h3>
                        </header>
                        <p>Now it&#39;s time to do some routing on top of OWIN</p>

                        <div class="tags">
                            
                                <a class="icon icon-tag" href="/tagged/owin.html"><span>owin</span></a>
                            
                                <a class="icon icon-tag" href="/tagged/web.html"><span>web</span></a>
                            
                        </div>
                    </article>
                </li>
            
        </ul>
    </section>
</div>

                    <div id="content" class="8u skel-cell-mainContent">
                        <article class="is-post">
                            <p>Recently I got to work on a project where we were building an ASP.Net WebAPI project for the client. One of the requirements of this project was that the API which we produced was authenticated, basically everything exposed had to be authenticated, and because it was a brand new project we decided to go down the path of WebAPI 2.0 and use the new Katana/OWIN system along with OAuth for the authentication.</p>
<p>Another hurdle we had when putting the API together was that it was to sit on top of a legacy system which contained a lot of business logic which was written in a way which we couldn&#39;t unit test, it was very tightly coupled to the database and as our timeline&#39;s didn&#39;t afford us to rewrite it all from scratch we instead opted to rely on integration testing.</p>
<p>But that raises an important question, how do you run your WebAPI end-point to be used in the tests? You could:</p>
<ul>
<li>Start up IIS Express, like you&#39;re <em>F5-ing</em> from Visual Studio (how we were developing)</li>
<li>Deploy to IIS, but then you&#39;re deploying code that hasn&#39;t ticked all the boxes</li>
</ul>
<p>Neither of these were ideal solutions, while IIS Express is <em>ok</em> for development it&#39;s not truly IIS so you&#39;re integration tests are already one step removed from the real environment, meaning they are less accurate. As for deploying to IIS, we deemed that to be equally as risky; you&#39;re either requiring the build server to also have IIS running on it or you&#39;re deploying to another server and then you&#39;ve got to handle the deployments, how do you setup/teardown the IIS instance? Do you do it as part of the test run? Again this was feeling like adding risk that we shouldn&#39;t need to have for preconditions.</p>
<h1 id="owin-to-the-rescue">OWIN to the rescue</h1>
<p>I&#39;ve blogged and presented about OWIN in the past, it&#39;s a really cool concept and this was the first time I was looking to do a production deployment using it, and there&#39;s one feature of OWIN that made it really appealing to solve our problems... Self Hosting.</p>
<p>Because OWIN is a separation between your code and the hosting platform your code doesn&#39;t care how it&#39;s hosted, only that it is, so you can go from hosting in IIS to self hosting inside an assembly with very little effort and this is what we were enticed by, through the self hosting we could spin up our API project <strong>inside of the test project as a HTTP server</strong> and then interact with it via HTTP client requests! AWESOME!</p>
<p>I&#39;m not going to blog on how to do that, <a href="http://www.strathweb.com/2013/12/owin-memory-integration-testing/">Filip W beat me to it</a> so that solved our first problem, being able to setup an integration test which ran our server.</p>
<p><em>Side note: You may be thinking that because we&#39;re using Self Host and not IIS (which is the production host) that we&#39;ve got a similar problem to using IIS Express but I&#39;d disagree. We&#39;re still using the full WebAPI stack, we&#39;re still using the full OWIN/Katana stack, we&#39;re just not using IIS and you&#39;re application should be none the wiser. If you&#39;re application knows it&#39;s running on IIS then I&#39;d argue you have a bigger problem.</em></p>
<h1 id="handling-authentication">Handling authentication</h1>
<p>As I said one of the main bridges we&#39;d have to cross on this project was that all the API calls were to be authenticated, which means that when you&#39;re running your tests you need to take that into account. So what do you do? Well you could write something to bypass the authentication for the test run, but then you&#39;re integration test is no longer really representative.</p>
<p>But what you need to remember is that because you&#39;re running your code through a self hosted WebAPI you&#39;ve got the full WebAPI stack, so the <code>[Authorize]</code> attribute will be in effect so you&#39;re going to actually have an authenticated request pipeline.</p>
<p>Ok, let&#39;s take the starting point that <a href="http://www.strathweb.com">Filip W</a> gave us, and start expanding on it, I&#39;m going to extract my server set up into its own base class:</p>
<pre class="highlighted"><code class="axapta"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServerTest</span>
{</span>
    <span class="keyword">protected</span> TestServer <span class="keyword">server</span>;

    [TestInitialize]
    <span class="keyword">public</span> <span class="keyword">void</span> Setup()
    {
        <span class="keyword">server</span> = TestServer.Create(app =&gt;
        {
            var startup = <span class="keyword">new</span> Startup();
            startup.ConfigureAuth(app);

            var config = <span class="keyword">new</span> HttpConfiguration();
            WebApiConfig.Register(config);

            app.UseWebApi(config);
        });
    }

    [TestCleanup]
    <span class="keyword">public</span> <span class="keyword">void</span> Teardown()
    {
        <span class="keyword">if</span> (<span class="keyword">server</span> != <span class="keyword">null</span>)
            <span class="keyword">server</span>.Dispose();
    }
}</code></pre>
<p>So what we&#39;ve got here is a call to create a new in-memory OWIN server, it&#39;s using the <code>Startup</code> class that my WebAPI app would use, as well as the WebAPI configuration (so routes, filters, etc) are configured. Now I want to make it easier to handle the <code>GET</code> and <code>POST</code> methods. To do this I&#39;m going to add an <code>abstract</code> property to represent the URI that the tests are for, and two method stubs:</p>
<pre class="highlighted"><code class="cs"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> Uri { <span class="keyword">get</span>; }

<span class="keyword">protected</span> <span class="keyword">virtual</span> async Task&lt;HttpResponseMessage&gt; GetAsync()
{
    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();
}

<span class="keyword">protected</span> <span class="keyword">virtual</span> async Task&lt;HttpResponseMessage&gt; PostAsync&lt;TModel&gt;(TModel model)
{
    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException
}</code></pre>
<p>Now I&#39;m going to quickly jump over to writing some integration tests for my user registration because well I&#39;ll need to register a user before I can run and tests:</p>
<pre class="highlighted"><code class="vala">[TestClass]
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountControllerTests</span> : <span class="title">BaseServerTest</span>
{</span>
    [TestMethod]
    <span class="keyword">public</span> <span class="keyword">async</span> Task CanRegisterUser()
    {
    }

    <span class="keyword">private</span> <span class="keyword">string</span> uriBase = <span class="string">"/api/account"</span>;
    <span class="keyword">private</span> <span class="keyword">string</span> uri = <span class="keyword">string</span>.Empty;

    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> Uri
    {
        <span class="keyword">get</span> { <span class="keyword">return</span> uri; }
    }
}</code></pre>
<p>I&#39;ve split the URI into two parts, there&#39;s the URI base, being <code>/api/account</code> and the <em>actual</em> URI for the abstract class implementation. The reason for this is that (at least in the default WebAPI project template) the <code>AccountController</code> isn&#39;t just a REST interface, but instead has multiple methods on it that I&#39;ll want to hit (things like change password, login and so on which I <strong>won&#39;t</strong> cover in this post). So let&#39;s go ahead and implement the test method itself:</p>
<pre class="highlighted"><code class="avrasm">[TestMethod]
public async Task CanRegisterUser()
{
    uri = uriBase + <span class="string">"/register"</span><span class="comment">;</span>

    var model = new RegisterBindingModel
    {
        UserName = <span class="string">"aaronpowell"</span> + DateTimeOffset<span class="preprocessor">.Now</span><span class="preprocessor">.Ticks</span>,
        Password = <span class="string">"password"</span>,
        ConfirmPassword = <span class="string">"password"</span>
    }<span class="comment">;</span>

    var response = await PostAsync(model)<span class="comment">;</span>

    Assert<span class="preprocessor">.AreEqual</span>(HttpStatusCode<span class="preprocessor">.OK</span>, response<span class="preprocessor">.StatusCode</span>)<span class="comment">;</span>
}</code></pre>
<p>What am I doing here? I&#39;m:</p>
<ul>
<li>Saying that this request is going to hit <code>/api/account/register</code></li>
<li>Using the model which the <code>AccountContoller.Register</code> method is taking as an input argument</li>
<li>Calling my <code>PostAsync</code> method</li>
<li>Asserting that we got a successful response</li>
</ul>
<p>Additionally you could write an assert that peaks into the database and validates that the user is there, but that&#39;s an exercise for the reader.</p>
<p>I really like that you can use the model from WebAPI to do the processing, this gives us the advantage of:</p>
<ul>
<li>Type safety, if the class is refactored our test will also be refactored</li>
<li>We leverage model binding and model validation</li>
</ul>
<p><em>Side note: You&#39;ll notice I&#39;m appending <code>DateTimeOffset.Now.Ticks</code> to the username, that&#39;s because we need a unique username each time. Depending on whether you&#39;re creating a new DB for each test run or not you may want to handle this better.</em></p>
<p>So how does our <code>PostAsync</code> work? Well let&#39;s implement it:</p>
<pre class="highlighted"><code class="cs"><span class="keyword">protected</span> <span class="keyword">virtual</span> async Task&lt;HttpResponseMessage&gt; PostAsync&lt;TModel&gt;(TModel model)
{
    <span class="keyword">return</span> await server.CreateRequest(Uri)
        .And(request =&gt; request.Content = <span class="keyword">new</span> ObjectContent(<span class="keyword">typeof</span>(TModel), model, <span class="keyword">new</span> JsonMediaTypeFormatter()))
        .PostAsync();
}</code></pre>
<p>Yep it&#39;s really quite simple. You&#39;ll see here that I&#39;m grabbing the <code>Uri</code> property our class implements, which saves it being passed in, and then we&#39;re just leveraging the methods available from the <code>TestServer</code> class to build up the request and eventually <code>POST</code> the content up. But how do we get the content up there? Well we leverage the <code>And</code> extension method which we have a lambda that can set properties on the request, in this case we setting the request content, serialized as JSON, but you can use any available <code>MediaTypeFormatter</code> so this can be nifty if you&#39;re working with your own formatters.</p>
<p>Now if we run our test it should pass with flying colours.</p>
<h2 id="making-a-get-">Making a <code>GET</code></h2>
<p>We&#39;ve got the <code>POST</code> sorted, what about <code>GET</code>? This time I&#39;m going to go for the <code>ValuesController</code> (which comes in the default project template). Now this is an authenticated controller so we can start off with writing a test that if there&#39;s no credentials we fail our test:</p>
<pre class="highlighted"><code class="python">[TestClass]
public <span class="class"><span class="keyword">class</span> <span class="title">ValuesControllerTests</span> :</span> BaseServerTest
{
    [TestMethod]
    public async Task ShouldGetUnauthorizedWithoutLogin()
    {
        var response = await GetAsync();

        Assert.AreEqual(HttpStatusCode.Unauthorized, response.StatusCode);
    }

    protected override string Uri
    {
        get { <span class="keyword">return</span> <span class="string">"/api/values"</span>; }
    }
}</code></pre>
<p>So this <code>Assert</code> should make sense, no credentials, you get a <code>401</code> response. But what does the <code>GetAsync</code> method look like?</p>
<pre class="highlighted"><code class="objectivec"><span class="keyword">protected</span> virtual async Task&lt;HttpResponseMessage&gt; GetAsync()
{
    <span class="keyword">return</span> await server<span class="variable">.CreateRequest</span>(Uri)<span class="variable">.GetAsync</span>();
}</code></pre>
<p>Sorry, not very exciting is it! Really all we&#39;re doing is nicely wrapping around the <code>CreateRequest</code> method call</p>
<h1 id="where-s-the-authentication-">Where&#39;s the authentication?</h1>
<p>Right we&#39;ve got a bunch of unauthenticated requests out of the way, now it&#39;s time to look at how we can do some authenticated requests. For this I&#39;m going to create another base class that extends our <code>BaseServerTest</code>:</p>
<pre class="highlighted"><code class="vala"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAuthenticatedTests</span> : <span class="title">BaseServerTest</span>
{</span>
    <span class="keyword">protected</span> virtual <span class="keyword">string</span> Username { <span class="keyword">get</span> { <span class="keyword">return</span> <span class="string">"aaronpowell"</span>; } }
    <span class="keyword">protected</span> virtual <span class="keyword">string</span> Password { <span class="keyword">get</span> { <span class="keyword">return</span> <span class="string">"password"</span>; } }

    <span class="keyword">private</span> <span class="keyword">string</span> token;
}</code></pre>
<p>For the authenticated tests I&#39;m going to do them against a user that is known to exist, you could do it a bunch of different ways, like performing a registration for each test, that really comes down to how complex your registration process is.</p>
<p>Also I don&#39;t want the author of authenticated tests to have to worry about the authentication side of things, it should <em>just work</em> for them. So to do this I&#39;m going to extend my <code>BaseServerTest</code> class to all me to run something when the server is setup:</p>
<pre class="highlighted"><code class="avrasm">[TestInitialize]
public void Setup()
{
    server = TestServer<span class="preprocessor">.Create</span>(app =&gt;
    {
        var startup = new Startup()<span class="comment">;</span>
        startup<span class="preprocessor">.ConfigureAuth</span>(app)<span class="comment">;</span>

        var config = new HttpConfiguration()<span class="comment">;</span>
        WebApiConfig<span class="preprocessor">.Register</span>(config)<span class="comment">;</span>

        app<span class="preprocessor">.UseWebApi</span>(config)<span class="comment">;</span>
    })<span class="comment">;</span>

    PostSetup(server)<span class="comment">;</span>
}

protected virtual void PostSetup(TestServer server)
{
}</code></pre>
<p>What I&#39;ve added here is a virtual method <code>PostSetup</code> which is called when the server is ready and then we can do additional stuff. Let&#39;s implement it in our <code>BaseAuthenticatedTest</code>:</p>
<pre class="highlighted"><code class="cs"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> PostSetup(TestServer server)
{
    <span class="keyword">var</span> tokenDetails = <span class="keyword">new</span> List&lt;KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;&gt;()
        {
            <span class="keyword">new</span> KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;(<span class="string">"grant_type"</span>, <span class="string">"password"</span>),
            <span class="keyword">new</span> KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;(<span class="string">"username"</span>, Username),
            <span class="keyword">new</span> KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;(<span class="string">"password"</span>, Password)
        };

    <span class="keyword">var</span> tokenPostData = <span class="keyword">new</span> FormUrlEncodedContent(tokenDetails);
    <span class="keyword">var</span> tokenResult = server.HttpClient.PostAsync(<span class="string">"/Token"</span>, tokenPostData).Result;
    Assert.AreEqual(HttpStatusCode.OK, tokenResult.StatusCode);

    <span class="keyword">var</span> body = JObject.Parse(tokenResult.Content.ReadAsStringAsync().Result);

    token = (<span class="keyword">string</span>)body[<span class="string">"access_token"</span>];
}</code></pre>
<p>Alright, what we&#39;re doing here is:</p>
<ul>
<li>Creating the details which are needed to be <code>POST</code>ed, this is the standard data you&#39;d provide to an OAuth request</li>
<li>URL Encode the data</li>
<li>Hit the <code>/Token</code> route with the data</li>
<li>Assert that it was a successful request</li>
<li>Extract the token from the response, I&#39;m just reading it out as JSON (which it is) and not worrying about strongly typing it</li>
</ul>
<p><em>Side note - you&#39;ll notice that I&#39;m using <code>PostAsync(...).Result</code> and not <code>async</code> &amp; <code>await</code>. The reason for this is a limitation in MSTest (and NUnit), you&#39;re setup can&#39;t have a return type (ie - <code>async Task</code>) so you&#39;re stuck with <code>async void</code> which gets dodgy quickly. It&#39;s easier to just do it synchronously.</em></p>
<p>With our authentication written now we need to make sure that we are passing it through on the request:</p>
<pre class="highlighted"><code class="objectivec"><span class="keyword">protected</span> override async Task&lt;HttpResponseMessage&gt; GetAsync()
{
    <span class="keyword">return</span> await server<span class="variable">.CreateRequest</span>(Uri)
        <span class="variable">.AddHeader</span>(<span class="string">"Authorization"</span>, <span class="string">"Bearer "</span> + token)
        <span class="variable">.GetAsync</span>();
}</code></pre>
<p>Really the only difference is that the <code>GetAsync</code> (and <code>PostAsync</code>) is that we add the <code>Authorization</code> header and properly format it to contain our bearer token.</p>
<p>Easy, we can now write a test like so:</p>
<pre class="highlighted"><code class="vala">[TestClass]
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuesAuthenticatedControllerTests</span> : <span class="title">BaseAuthenticatedTests</span>
{</span>
    [TestMethod]
    <span class="keyword">public</span> <span class="keyword">async</span> Task ShouldGetValuesWhenAuthenticated()
    {
        <span class="keyword">var</span> response = await GetAsync();

        <span class="keyword">var</span> values = await response.Content.ReadAsAsync&lt;IEnumerable&lt;<span class="keyword">string</span>&gt;&gt;();

        Assert.AreEqual(<span class="number">2</span>, values.Count());
    }

    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> Uri
    {
        <span class="keyword">get</span> { <span class="keyword">return</span> <span class="string">"/api/values"</span>; }
    }
}</code></pre>
<p>And we&#39;re done!</p>
<h1 id="conclusion">Conclusion</h1>
<p>So through this post we&#39;ve seen how we can use OWIN/Katana&#39;s self-hosting feature to host itself and then make requests against and authenticated API. We&#39;ve also abstracted away the authentication part of our integration tests so we don&#39;t need to think about it for each test which we write.</p>
<p>I&#39;ve published the code used for this blog <a href="https://github.com/aaronpowell/Owin.AuthenticatedTests">here on GitHub</a> so feel free to get it and have a play.</p>

                        </article>
                    </div>
                    <div class="8u skel-cell-mainContent">
                        <article class="is-post">
                            <div id="disqus_thread"></div>
<script>
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
window.disqus_shortname = 'aaronpowell'; // required: replace example with your forum shortname
window.disqus_identifier = document.title || 'Home';
window.disqus_developer = !! ~document.location.href.indexOf("localhost") ? 1 : 0;
window.disqus_url = document.location.origin + '/posts/2014-01-12-integration-testing-katana-with-auth.html';

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by</a>
<span class="logo-disqus"> Disqus</span>

                        </article>
                    </div>
                </div>
            </div>
        </div>

        <div id="footer-wrapper">

    <!-- Copyright -->
        <div id="copyright" class="container">
            <ul class="links">
                <li>&copy; Aaron Powell. All rights reserved</li>
                <li>Design: <a href="http://html5up.net/">HTML5 UP</a></li>
            </ul>
        </div>

</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-6399564-1']);
  _gaq.push(['_trackPageview']);

  (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
  })();

</script>

    </body>
</html>